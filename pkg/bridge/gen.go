package bridge

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/hashicorp/terraform/helper/schema"
)

var providerTemplate = `

// {{.TitleType}}Handler ...
type {{.TitleType}}Handler struct {
	provider *schema.Provider
}

// Create ...
func (h *{{.TitleType}}Handler) Create(desired *{{.TitleType}}) (*{{.TitleType}}, string, error) {
	rState := {{.TitleType}}Mapper(desired)
	id, err := bridge.Create(h.provider, "{{.TFType}}", rState)
	if err != nil {
		return nil, "", err
	}
	actual, err := h.Read(id)
	if err != nil {
		return nil, "", err
	}
	return actual, id, nil
}

// Read ...
func (h *{{.TitleType}}Handler) Read(externalID string) (*{{.TitleType}}, error) {
	actual, err := bridge.Read(h.provider, "{{.TFType}}", externalID)
	if err != nil {
		return nil, err
	}
	return {{.TitleType}}Unmapper(actual), nil
}

// Delete ...
func (h *{{.TitleType}}Handler) Delete(externalID string) error {
	return bridge.Delete(h.provider, "{{.TFType}}", externalID)
}

`

var mapperPrefix = `
func %sMapper(r *%s) *terraform.ResourceConfig {
	config := map[string]interface{}{}
 	`

var mapperSuffix = `return &terraform.ResourceConfig{
		Config: config,
	}
}
`

var unmapperPrefix = `
func %sUnmapper(state map[string]interface{}) *%s {
	r := &%s{}
`

var unmapper = `
if x, ok := state["%s"]; ok {
	r.%s = x.(%s)
}
`

var tagsUnmapper = `
if x, ok := state["%s"]; ok {
	r.%s = convertMap(x.(map[string]interface{}))
}
`

var unmapperWithPointerDeref = `
if x, ok := state["%s"]; ok {
	x := x.(%s)
	r.%s = &x
}
`

var tagsUnmapperWithPointerDeref = `
if x, ok := state["%s"]; ok {
	x := convertMap(x.(map[string]interface{}))
	r.%s = &x
}
`

var unmapperSuffix = `	return r
}
`

var prefix = `// Code generated by Lyra DO NOT EDIT.

// This code is generated on a per-provider basis using "tf-gen"
// Long term our hope is to remove this generation step and adopt dynamic approach

package generated

import (
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/terraform/terraform"
	"github.com/lyraproj/lyra/pkg/bridge"
	"github.com/lyraproj/puppet-evaluator/eval"
	"github.com/lyraproj/servicesdk/service"
)

func convertMap(in map[string]interface{}) map[string]string {
	m  := map[string]string{}
	for k,v := range in {
		m[k] = v.(string)
	}
	return m
}

func unconvertMap(in map[string]string  ) map[string]interface{} {
	m  := map[string]interface{}{}
	for k,v := range in {
		m[k] = v
	}
	return m
}

`

func getGoType(key string, s *schema.Schema) string {
	// FIXME many missing types including all maps except tags ...
	var t string
	switch s.Type {
	case schema.TypeString:
		t = "string"
	case schema.TypeMap:
		if key == "tags" {
			t = "map[string]string"
		}
	case schema.TypeBool:
		t = "bool"
	default:
		return ""
	}
	return t
}

func generateResource(handler io.Writer, rType string, r *schema.Resource) {
	fmt.Fprintf(handler, "type %s struct {\n", rType)
	id := fmt.Sprintf("%s_id", rType)
	fmt.Fprintf(handler, "     %s *string\n", id)
	for k, v := range r.Schema {
		if k == "type" {
			k = "resource_type"
		}
		goType := getGoType(k, v)
		if goType == "" {
			log.Printf("Ignoring unsupported schema: %s -> %s -> %v", rType, k, v.Type)
			continue
		}
		if !v.Required {
			goType = "*" + goType
		}
		fmt.Fprintln(handler, "    ", strings.Title(k), goType)
	}
	fmt.Fprintf(handler, "}\n\n")
}

func generateMapper(handler io.Writer, rType string, r *schema.Resource) {
	fmt.Fprintf(handler, mapperPrefix, rType, rType)
	for k, v := range r.Schema {
		if k == "type" {
			k = "resource_type"
		}
		if getGoType(k, v) == "" {
			log.Printf("Ignoring unsupported schema: %s -> %s -> %v", rType, k, v.Type)
			continue
		}
		if v.Type == schema.TypeMap {
			if v.Required {
				fmt.Fprintf(handler, "    config[\"%s\"] = unconvertMap(r.%s)\n", k, strings.Title(k))
			} else {
				fmt.Fprintf(handler, "if r.%s != nil {\n", strings.Title(k))
				fmt.Fprintf(handler, "    config[\"%s\"] = unconvertMap(*r.%s)\n", k, strings.Title(k))
				fmt.Fprintf(handler, "}\n")
			}
		} else {
			if v.Required {
				fmt.Fprintf(handler, "    config[\"%s\"] = r.%s\n", k, strings.Title(k))
			} else {
				fmt.Fprintf(handler, "if r.%s != nil {\n", strings.Title(k))
				fmt.Fprintf(handler, "    config[\"%s\"] = *r.%s\n", k, strings.Title(k))
				fmt.Fprintf(handler, "}\n")
			}
		}
	}
	fmt.Fprintf(handler, mapperSuffix)
}

func generateUnmapper(handler io.Writer, rType string, r *schema.Resource) {
	fmt.Fprintf(handler, unmapperPrefix, rType, rType, rType)
	id := fmt.Sprintf("%s_id", rType)
	fmt.Fprintf(handler, unmapperWithPointerDeref, "external_id", "string", strings.Title(id))
	for k, v := range r.Schema {
		if k == "type" {
			k = "resource_type"
		}
		goType := getGoType(k, v)
		if goType == "" {
			log.Printf("Ignoring unsupported schema: %s -> %s -> %v", rType, k, v.Type)
			continue
		}
		if v.Type == schema.TypeMap {
			if v.Required {
				fmt.Fprintf(handler, tagsUnmapper, k, strings.Title(k))
			} else {
				fmt.Fprintf(handler, tagsUnmapperWithPointerDeref, k, strings.Title(k))
			}
		} else {
			if v.Required {
				fmt.Fprintf(handler, unmapper, k, strings.Title(k), goType)
			} else {
				fmt.Fprintf(handler, unmapperWithPointerDeref, k, goType, strings.Title(k))
			}
		}
	}
	fmt.Fprintf(handler, unmapperSuffix)
}

type providerType struct {
	TitleType string
	TFType    string
}

func generateProvider(handler io.Writer, rType string) {
	tmpl := template.Must(template.New("provider").Parse(providerTemplate))
	var buf bytes.Buffer
	err := tmpl.Execute(&buf, providerType{strings.Title(rType), rType})
	if err != nil {
		panic(err)
	}
	fmt.Fprintf(handler, buf.String())
}

func mkdirs(filename string) {
	dirName := filepath.Dir(filename)
	if _, serr := os.Stat(dirName); serr != nil {
		merr := os.MkdirAll(dirName, os.ModePerm)
		if merr != nil {
			panic(merr)
		}
	}
}

// Generate the Lyra boilerplate needed to bridge to a Terraform provider
func Generate(p *schema.Provider, ns, filename string) {

	handler := bytes.NewBufferString("")
	fmt.Fprintf(handler, prefix)
	fmt.Fprintf(handler, "func Initialize(sb *service.ServerBuilder, p *schema.Provider) {\n")
	fmt.Fprintf(handler, "    var evs []eval.Type\n")

	rTypes := make([]string, len(p.ResourcesMap))
	i := 0
	for k := range p.ResourcesMap {
		rTypes[i] = k
		i++
	}
	rTypes = sort.StringSlice(rTypes)

	for _, rType := range rTypes {
		rTitleType := strings.Title(rType)
		fmt.Fprintf(handler, "    evs = sb.RegisterTypes(\"%s\", %s{})\n", ns, rTitleType)
		fmt.Fprintf(handler, "    sb.RegisterHandler(\"%s::%sHandler\", &%sHandler{provider: p}, evs[0])\n", ns, rTitleType, rTitleType)
	}
	fmt.Fprintf(handler, "}\n\n")

	for _, rType := range rTypes {
		r := p.ResourcesMap[rType]
		generateResource(handler, strings.Title(rType), r)
		generateMapper(handler, strings.Title(rType), r)
		generateUnmapper(handler, strings.Title(rType), r)
		generateProvider(handler, rType)
	}

	mkdirs(filename)
	err := ioutil.WriteFile(filename, handler.Bytes(), 0644)
	if err != nil {
		panic(err)
	}

}
